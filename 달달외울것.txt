변수 : 메모리에 값을 기록하기 위한 공간
변수의 선언 : 메모리 공간에 데이터를 저장할 수 있는 공간을 할당하는 것

제어문 : 코드의 흐름을 제어한다해서 제어문
switch문 : 조건이 많을때 사용 하면 좋음 사용할 때 break문 필수
do-while문 사용시 while문 옆에 ; 붙이기

배열 선언 : 메모리에 배열을 참조하는 변수 공간을 만드는 것
	(값 직접 저장 X, 배열의 주소를 저장)
배열 할당 : 실제 값을 저장할 수 잇는 배열을 메모리에 생성

Heap 영역에 할당된 공간은 절대 비어있을 수 없다 -> 최초 할당시 JVM 기본값이 자동 저장된다 (컴파일러)
-> ex) new int[3] => {0, 0, 0}
-> (boolean : false / 나머지는 0 / 참조형 null)

복사한 배열(arr2)을 수정하게 될 경우
원래 배열(arr1) 또한 수정되는 결과를 얻게 됨

System.arraycopy(복사할 배열, 복사할 배열의 인덱스 시작 번호, 불여넣을 배열, 불여넣을 배열의 인덱스 시작 번호, 복사할 배열의 길이)

length : arrays(int[], double[], String[]) 배열의 길이를 알고자 할 때 사용
length() : 문자열의 길이를 알고자 할 때 사용
size() : 컬렉션 프레임워크 타입의 길이 알고자 할 때 사용

객체(Object : 물건, 객체) : 독립적으로 각각 구분해서 인식할 수 있는 모든 것
객체 지향 언어 : 독립적으로 각각 구분해서 인식할 수 있는 것을 목표로 하는 코딩 방식
->현실 세계는 사물이나 개념처럼 독립되고 구분되는 각각의 객체로 이루어져 있으며, 
   발생하는 모든 사건들은 객체간의 상호작용이다. 
   이 개념을 컴퓨터로 옮겨 놓아 만들어낸 것이 객체지향 언어이다.

1. 캡슐화(Encapsulation) : 
	1) 추상화를 통해 정리된 데이터들과 기능을 하나로 묶어 관리하는 기법
	2) 클래스의 가장 중요한 목적인 데이터의 직접 접근제한을 원칙으로 하여 
	   클래스 외부에서 데이터의 직접적인 접근을 막고, 
	   대신 간접적으로 데이터에 접근할 수 메소드를 클래스 내부에 작성하는 방법

2. 추상화(Abstraction) : 공통된 코드만 작성 -> 개별적인 것들은 다 제거
3. 상속(Inheritance) : 상속을 하게 되면 코드 길이 감소
4. 다형성(Polymorphism) : 다양한 상태를 지니는 성질

현실에서 객채란? : 자신의 속성(값, 데이터)과 기능(동작, 행동)이 다른 것들과 구분되어 식별 가능한 것
자바에서 객체란? : 클래스에 정의된 내용대로 new 연산자를 통해 메모리 영역에 생성된 것

MVC패턴
1. Model : 프로그램, 어플리케이션의 데이터, 비즈니스 로직 담당
2. View : 사용자에게 데이터를 시각적으로 표현하는 부분
3. Controller : model, view간의 상호작용을 조정, 제어하는 역할의 담당
	      사용자의 입력 처리하고 대응하는 작업 담당

VO(Value Object) : 값 저장용 객체를 만들기 위한 클래스를 모아두는 패키지

Object = 객체란 뜻도 있지만 현실에서의 객체를 Object라 함
객체 = instance (클래스에 정의된 객체를 instance라 함)
멤버변수 = reference (필드, 필드변수, 멤버변수, 클래스 변수)

--------------------------------------------------------------

클래스 선언 : [접근제한자] [예약어] class 클래스명 {} -> [] 안에 잇는 것들은 생략 가능
"~" 이름 : 틸드
클래스 다이어그램 : 
- : private
+ : public
~ : default
# : protected

heap : 동적 메모리 영역
static : 정적 메모리 영역

내가 이해한 static : 해당 클래스 안에 static 변수를 선언하면 그 해당 변수는 그 클래스를 통해 만든 모든 객체들끼리 공유하는 변수라는 것이다
		Student 라는 클래스를 통해 2개의 객체를 생성하고, 각 객체의 이름을 std1, std2 라고 해보자
		Student 클래스 안에 public static String schoolName = "KH고등학교"; 라는 static 변수가 있고
		std1도 std2도 그 값을 지니고 있다. 여기서 std1.schoolName = "서울고등학교"; 라고 변수를 새로 대입을 하면 원래 기존에는
		std1의 schoolName만 변해야 하는데 schoolName은 static 변수이기 때문에 std2.schoolName도 값이 "서울고등학교"로 변하는 것이다
		
		올바른 작성법 : 해당 클래스명.변수명 == Student.schoolName 이렇게

오버로딩 : 한 클래스 내에 동일한 이름의 메서드를 여러 개 작성하는 기법
오버로딩 작성 규칙 :
1) 같은 메서드 이름
2) 다른 매개변수의 개수 또는 다른 매개변수 타입, 순서 (매개변수의 자료형, 개수, 순서가 달라야한다)
3) 리텁 타입은 같아도 되고 달라도 된다

자바는 기본적으로 필드명, 생성자명, 메서드명, 변수명의 중복을 허용하지 않음 

가변인자 : 매개변수의 개수를 유동적으로 설정하는 방법 (매개변수의 수에 제한이 없음)
작성 방법 : (자료형... 변수명) -> ex) (String... str1, str2)
public void ex1(int... numbers) {
}
-> ex1(100, 200) 또는 ex1(300, 700, 500)

stack의 자료구조 : LIFO(Last-Input-First-Out)

---------------------------------------------------------------------

객체 배열 : 객체 참조형 변수를 저장하는 배열

------------------------------------ 상속 ------------------------------------ 

상속 : 부모가 가진 (속성 + 기능) -> 자식 객체에 물려줌으로
자식 객체 = 자식(자기만의 속성 + 기능) + (부모가 가진 속성 + 기능)

DTO(Data Transfer Object)

자바는 다중 상속 미지원

super()와 super의 차이 : 
1) super() : 부모 객체 생성자를 뜻함
2) super : 부모 객체를 가리키는 참조변수

오버라이딩 : 상속 받은 부모 메서드 재작성 하는 것 (부모의 기능을 후손이 일부 고쳐 사용하겠다는 의미)
작성법 : @Override 어노테이션 명시 필수
성립조건 : 
1) 동일한 메서드 이름 
2) 동일한 매개변수의 개수, 타입, 순서
3) 동일한 리턴 타입
4) private 메서드 오버라이딩 불가

어노테이션(Annotation) : 컴파일러에게 알려주기 위한 코드 (컴파일러 인식용 주석)

새로 생성한 객체에서 오버라이딩 하여 사용하면 기존에 print 구문에 객체 이름만 입력하여 출력했을 때 나오는 참조변수 주소값이 아닌
오버라이딩 한 toString()의 내용을 수행하게 된다
ex) System.out.println(객체); = 주소값
toString() 오버라이딩 했을 시 -> System.out.println(객체); = 오버라이딩하며 새롭게 정의한 내용 수행함

클래스 앞에 final 예약어가 붙을 시 상속이 불가능한 클래스가 됨
메서드 앞에 final 예약어가 붙을 시 상속 이후 자식 클래스에서 오버라이딩이 불가능함

------------------------------------ 다형성 ------------------------------------ 

다형성은 상속받은 관계에 한해서만 가능한 기술이다
부모클래스 변수명 = new 자식 클래스()

그러면 car라는 객체를 만들어 사용하면 되는 걸 굳이 이름이 다른 클래스를 만들어 car라는 참조변수에 객체를 대입하는 이유는?

instanceof : 객체의 자료형을 검사하는 연산자

------------------------------------ 추상 ------------------------------------ 

추상 클래스 : 추상 메서드를 사용하기 위해 클래스도 추상 클래스로 만들어야 한다

추상 메서드 : 상속 시 반드시 구현해야 하는 즉, 오버라이딩이 강제화도는 메서드()

추상 클래스 특징 :
1) 미완성 클래스로 자체적 객체 생성 불가 (상속하여 객체 생성)
2) 메서드 없이 추상 클래스 선언 가능 / 추상 클래스가 아닌 일반 클래스 안에 추상 메서드는 사용 불가 / 추상 메서드를 사용하려면 클래스를 추상화 선언을 해야함
3) 추상 클래스 내 일반 변수, 메서드 포함 가능
4) 객체 생성 X, 참조형 변수 타입으로 사용 가능

추상 클래스 장점 : 자식에게 공통된 멤버 제공 / 일부 기능의 구현을 강제화

정적 바인딩 : 클래스를 상속받은 부모 자식 관계에서 자식이 부모의 기능을 오버라이딩 하고 부모의 타입으로 업캐스팅되어 있는 상태에서  그 기능을 호출할 때 컴파일러는 부모의 기능으로 인식을 하지만 프로그램 실행시에는 오버라이딩 된 자식의 기능을 수행하게 됨
ex) 
부모 :
public void move(){
}
자식 :
@Override
public void move(){
}

부모 test = new 자식();
자식.move(); -> 컴파일러 인식 : 부모.move();
하지만 프로그램 실행 시 -> 자식.move(); 를 수행(부모.move() 를 오버라이딩함)

한줄요약 : 상속 관계(상속), 업캐스팅(다형성), 부모 기능 오버라이딩 후 오버라이딩한 기능 호출할 때 동적 바인딩이 성립된다

------------------------------------ 인터페이스 ------------------------------------ 

자바에서의 인터페이스란 : 클래스간의 접점 -> 클래스가 공통적으로 가져야 하는 필드, 메서드를 모아두고 상속
인터페이스의 필드는 묵시적으로 -> public static final 임
인터페이스 상속 시 -> implements 로 상속 받기




단축키 --------------------------------------------------------------
ctrl + shift + O : import 안 된 모든 클래스 import
alt + shift + s : getter, setter 생성 단축키