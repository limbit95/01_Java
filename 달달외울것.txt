변수 : 메모리에 값을 기록하기 위한 공간
변수의 선언 : 메모리 공간에 데이터를 저장할 수 있는 공간을 할당하는 것

제어문 : 코드의 흐름을 제어한다해서 제어문
switch문 : 조건이 많을때 사용 하면 좋음 사용할 때 break문 필수
do-while문 사용시 while문 옆에 ; 붙이기

배열 선언 : 메모리에 배열을 참조하는 변수 공간을 만드는 것
	(값 직접 저장 X, 배열의 주소를 저장)
배열 할당 : 실제 값을 저장할 수 잇는 배열을 메모리에 생성

Heap 영역에 할당된 공간은 절대 비어있을 수 없다 -> 최초 할당시 JVM 기본값이 자동 저장된다 (컴파일러)
-> ex) new int[3] => {0, 0, 0}
-> (boolean : false / 나머지는 0 / 참조형 null)

복사한 배열(arr2)을 수정하게 될 경우
원래 배열(arr1) 또한 수정되는 결과를 얻게 됨

System.arraycopy(복사할 배열, 복사할 배열의 인덱스 시작 번호, 불여넣을 배열, 불여넣을 배열의 인덱스 시작 번호, 복사할 배열의 길이)

length : arrays(int[], double[], String[]) 배열의 길이를 알고자 할 때 사용
length() : 문자열의 길이를 알고자 할 때 사용
size() : 컬렉션 프레임워크 타입의 길이 알고자 할 때 사용

객체(Object : 물건, 객체) : 독립적으로 각각 구분해서 인식할 수 있는 모든 것
객체 지향 언어 : 독립적으로 각각 구분해서 인식할 수 있는 것을 목표로 하는 코딩 방식
->현실 세계는 사물이나 개념처럼 독립되고 구분되는 각각의 객체로 이루어져 있으며, 
   발생하는 모든 사건들은 객체간의 상호작용이다. 
   이 개념을 컴퓨터로 옮겨 놓아 만들어낸 것이 객체지향 언어이다.

1. 캡슐화(Encapsulation) : 
	1) 추상화를 통해 정리된 데이터들과 기능을 하나로 묶어 관리하는 기법
	2) 클래스의 가장 중요한 목적인 데이터의 직접 접근제한을 원칙으로 하여 
	   클래스 외부에서 데이터의 직접적인 접근을 막고, 
	   대신 간접적으로 데이터에 접근할 수 메소드를 클래스 내부에 작성하는 방법

2. 추상화(Abstraction) : 공통된 코드만 작성 -> 개별적인 것들은 다 제거
3. 상속(Inheritance) : 상속을 하게 되면 코드 길이 감소
4. 다형성(Polymorphism) : 다양한 상태를 지니는 성질

현실에서 객채란? : 자신의 속성(값, 데이터)과 기능(동작, 행동)이 다른 것들과 구분되어 식별 가능한 것
자바에서 객체란? : 클래스에 정의된 내용대로 new 연산자를 통해 메모리 영역에 생성된 것

MVC패턴
1. Model : 프로그램, 어플리케이션의 데이터, 비즈니스 로직 담당
2. View : 사용자에게 데이터를 시각적으로 표현하는 부분
3. Controller : model, view간의 상호작용을 조정, 제어하는 역할의 담당
	      사용자의 입력 처리하고 대응하는 작업 담당

VO(Value Object) : 값 저장용 객체를 만들기 위한 클래스를 모아두는 패키지

Object = 객체란 뜻도 있지만 현실에서의 객체를 Object라 함
객체 = instance (클래스에 정의된 객체를 instance라 함)
멤버변수 = reference (필드, 필드변수, 멤버변수, 클래스 변수)

--------------------------------------------------------------

클래스 선언 : [접근제한자] [예약어] class 클래스명 {} -> [] 안에 잇는 것들은 생략 가능
"~" 이름 : 틸드
클래스 다이어그램 : 
- : private
+ : public
~ : default
# : protected

heap : 동적 메모리 영역
static : 정적 메모리 영역

내가 이해한 static : 해당 클래스 안에 static 변수를 선언하면 그 해당 변수는 그 클래스를 통해 만든 모든 객체들끼리 공유하는 변수라는 것이다
		Student 라는 클래스를 통해 2개의 객체를 생성하고, 각 객체의 이름을 std1, std2 라고 해보자
		Student 클래스 안에 public static String schoolName = "KH고등학교"; 라는 static 변수가 있고
		std1도 std2도 그 값을 지니고 있다. 여기서 std1.schoolName = "서울고등학교"; 라고 변수를 새로 대입을 하면 원래 기존에는
		std1의 schoolName만 변해야 하는데 schoolName은 static 변수이기 때문에 std2.schoolName도 값이 "서울고등학교"로 변하는 것이다
		
		올바른 작성법 : 해당 클래스명.변수명 == Student.schoolName 이렇게

오버로딩 : 한 클래스 내에 동일한 이름의 메서드를 여러 개 작성하는 기법
오버로딩 작성 규칙 :
1) 같은 메서드 이름
2) 다른 매개변수의 개수 또는 다른 매개변수 타입, 순서 (매개변수의 자료형, 개수, 순서가 달라야한다)
3) 리텁 타입은 같아도 되고 달라도 된다

자바는 기본적으로 필드명, 생성자명, 메서드명, 변수명의 중복을 허용하지 않음 

가변인자 : 매개변수의 개수를 유동적으로 설정하는 방법 (매개변수의 수에 제한이 없음)
작성 방법 : (자료형... 변수명) -> ex) (String... str1, str2)
public void ex1(int... numbers) {
}
-> ex1(100, 200) 또는 ex1(300, 700, 500)

stack의 자료구조 : LIFO(Last-Input-First-Out)

---------------------------------------------------------------------

객체 배열 : 객체 참조형 변수를 저장하는 배열

------------------------------------ 상속 ------------------------------------ 

상속 : 부모가 가진 (속성 + 기능) -> 자식 객체에 물려줌으로
자식 객체 = 자식(자기만의 속성 + 기능) + (부모가 가진 속성 + 기능)

DTO(Data Transfer Object)

자바는 다중 상속 미지원

super()와 super의 차이 : 
1) super() : 부모 객체 생성자를 뜻함
2) super : 부모 객체를 가리키는 참조변수

오버라이딩 : 상속 받은 부모 메서드 재작성 하는 것 (부모의 기능을 후손이 일부 고쳐 사용하겠다는 의미)
작성법 : @Override 어노테이션 명시 필수
성립조건 : 
1) 동일한 메서드 이름 
2) 동일한 매개변수의 개수, 타입, 순서
3) 동일한 리턴 타입
4) private 메서드 오버라이딩 불가

어노테이션(Annotation) : 컴파일러에게 알려주기 위한 코드 (컴파일러 인식용 주석)

새로 생성한 객체에서 오버라이딩 하여 사용하면 기존에 print 구문에 객체 이름만 입력하여 출력했을 때 나오는 참조변수 주소값이 아닌
오버라이딩 한 toString()의 내용을 수행하게 된다
ex) System.out.println(객체); = 주소값
toString() 오버라이딩 했을 시 -> System.out.println(객체); = 오버라이딩하며 새롭게 정의한 내용 수행함

클래스 앞에 final 예약어가 붙을 시 상속이 불가능한 클래스가 됨
메서드 앞에 final 예약어가 붙을 시 상속 이후 자식 클래스에서 오버라이딩이 불가능함

------------------------------------ 다형성 ------------------------------------ 

다형성은 상속받은 관계에 한해서만 가능한 기술이다
부모클래스 변수명 = new 자식 클래스()

그러면 car라는 객체를 만들어 사용하면 되는 걸 굳이 이름이 다른 클래스를 만들어 car라는 참조변수에 객체를 대입하는 이유는?

instanceof : 객체의 자료형을 검사하는 연산자

------------------------------------ 추상 ------------------------------------ 

추상 클래스 : 추상 메서드를 사용하기 위해 클래스도 추상 클래스로 만들어야 한다

추상 메서드 : 상속 시 반드시 구현해야 하는 즉, 오버라이딩이 강제화도는 메서드()

추상 클래스 특징 :
1) 미완성 클래스로 자체적 객체 생성 불가 (상속하여 객체 생성)
2) 메서드 없이 추상 클래스 선언 가능 / 추상 클래스가 아닌 일반 클래스 안에 추상 메서드는 사용 불가 / 추상 메서드를 사용하려면 클래스를 추상화 선언을 해야함
3) 추상 클래스 내 일반 변수, 메서드 포함 가능
4) 객체 생성 X, 참조형 변수 타입으로 사용 가능

추상 클래스 장점 : 자식에게 공통된 멤버 제공 / 일부 기능의 구현을 강제화

정적 바인딩 : 클래스를 상속받은 부모 자식 관계에서 자식이 부모의 기능을 오버라이딩 하고 부모의 타입으로 업캐스팅되어 있는 상태에서  그 기능을 호출할 때 컴파일러는 부모의 기능으로 인식을 하지만 프로그램 실행시에는 오버라이딩 된 자식의 기능을 수행하게 됨
ex) 
부모 :
public void move(){
}
자식 :
@Override
public void move(){
}

부모 test = new 자식();
자식.move(); -> 컴파일러 인식 : 부모.move();
하지만 프로그램 실행 시 -> 자식.move(); 를 수행(부모.move() 를 오버라이딩함)

한줄요약 : 상속 관계(상속), 업캐스팅(다형성), 부모 기능 오버라이딩 후 오버라이딩한 기능 호출할 때 동적 바인딩이 성립된다

------------------------------------ 인터페이스 ------------------------------------ 

자바에서의 인터페이스란 : 클래스간의 접점 -> 클래스가 공통적으로 가져야 하는 필드, 메서드를 모아두고 상속
인터페이스의 필드는 묵시적으로 -> public static final 임
인터페이스 상속 시 -> implements 로 상속 받기

------------------------------------ 예외 처리 ------------------------------------ 

Exception도 오버라이딩 가능 : 오버라이딩 시 thorws 하는 Exception의 개수와 상관없이 처리 범위가 같거나 후손이어야 함
- 이런 점을 이용하여 사용자 정의 예외발생 처리도 가능하다

------------------------------------ 컬렉션 ------------------------------------ 

컬렉션 : 자바에서 제공하는 자료구조 모음(List, Set, Map)

List, Set, Map : 배열보다 진화된 형태, 여러 데이터를 관리하기 위함

객체만 저장할 수 있는 컬렉션에 기본 자료형을 저장해야 하는 경우 이 Wrapper 클래스를 사용하면 된다
Wrapper 클래스 8가지 : Boolean, Byte, Short, Long, Float, Double, Integer(int), Character(char)

Collection 안의 List, Set, Map은 클래스간의 접점을 만들어주는 인터페이스.

List 계열 : 순서 유지O 및 저장, 중복 저장 가능 (ArrayList, Vector, LinkedList)
1) List는 자료들을 순차적으로 나열한 자료구조로 인덱스로 관리됨 
2) 기본적으로 배열 모양임

Set 계열 : 순서 유지X 및 저장, 중복 저장 안됨 (HashSet, TreeSet)
1) Set은 주머니 모양의 집합으로 저장 순서가 유지되지 않음
2) 중복 값이 들어올 수가 없다 -> 들어오게 되도 중복 값 제거를 수행함 (null도 중복을 허용하지 않으므로 1개의 null만 저장 가능함)

Map 계열 : 키와 값, 쌍으로 저장, 키는 중복 저장 안됨 (HashMap, HashTable, TreeMap, Properties)
1) 키(key)와 값(value) 형태로 구성 (키와 값은 모두 객체)
2) 키 중복 저장X 값 중복 저장O
3) 키 중복 시 -> 기존에 잇는 키에 해당하는 값을 덮어 씌움

Collections.sort(List<T> list) 을 사용할때는 정렬하고자 하는 리스트 객체 타입이 직접 Comparable을 상속받아 그 객체(클래스) 안에서
compareTo 메서드의 재정의를 통해 정렬 구현해야 하며
Collections.sort(List<T> list, Comparator<T> c) 는  Comparator 클래스를 통해 새로운 Comparatoer 객체를 생성 후 이 객체에 정렬하고자 하는 객체의 정렬 기준을
Comparator 클래스의 comparing 메서드를 통해 대입시키고 ex) -> Comparator<객체> 새로만든comparator = Comparator.comparing(객체::get필드값);  생성 후
생성한 이 Comparator 객체를 Collections.sort(List<객체>, 새로만든comparator); 이렇게 매개변수에 대입하여 정렬한다

참고로 사용자 정의 객체를 제외한 자바에서 제공하는 기본 자료형에는 Comparable과 Comparator가 이미 상속되어 있어
 해당 자료형들은 따로 상속받거나 클래스를 새로 대입하여 사용할 필요가 없다

TreeSet : 정렬 기능이 기본값임

Hash 라는 단어가 포함된 컬렉션 이용시 hashCode(), equals() 오버라이딩이 필수적으로 진행되어야 함

Map : 키(key)와 값(value)으로 구성
Map에 담겨있는 요소들을 순차적으로 접근하는 방법 2가지
1. keySet() 이용하기 -> key를 담은 Set을 iterator
2. entrySet() 이용하기 -> k:v를 담은 Set을 iterator
키 타입은 hashCode와 equals()메소드가 재정의되어 있는 String타입을 주로 사용

------------------------------------ Wrapper Class ------------------------------------ 
HTML 연결 시(요청 데이터 처리) 많이 사용
- HTML에 관련된 모든 값은 String
단, char(Character)는 별도로 존재하지 않음

byte b = Byte.parseByte("1");
short s = Short.parseShort("2");
int i = Integer.parseInt("3"); // 중요
long l = Long.parseLong("4"); // 중요
float f = Float.parseFloat("0.1");
double d = Double.parseDouble("0.2"); // 중요
boolean bool = Boolean.parseBoolean("true");

String의 불변성(immutable, 변하지 않는 성질 == 상수)
- 문자열이 수정되면 새로운 String 객체가 생성됨
String temp1 = "hello";
temp1 = "world";
위의 경우 같은 변수명에서 값만 바뀌었지만 결국 값이 수정되면서 새로운 String 객체가 생성되기에 주소값을 확인해보면 다른 것을 확인할 수 있다

String 리터럴("")로 객체를 생성한 경우 추가적으로 객체 생성하지 않고 기존에 존재하는 객체의 주소를 반환(재활용)함
String temp1 = "Hello!!";
String temp2 = "Hello!!"; 
위의 두 객체의 참조 주소값은 같음

new 연산자를 이용하여 생성하는 객체는 값이 같아도 참조주소값은 다르다
"" 리터럴로 생성된 String -> 상수풀 (JVM 관리)
new 연산자로 생성된 String -> Heap 영역 (사용자 관리)

StringBuilder / StringBuffer : String의 불변성 문제를 해결한 클래스
StringBuilder : Thread Safe 미제공 (비동기) -> 비동기화란? : 1번의 일이 시작했을 때 2번의 일을 시작할 준비를 하는 것
- 멀티쓰레드 환경에서는 StringBuilder 사용 시 쓰레드 충돌 가능성 있음 -> 글자 깨지거나 오류 발생
- 단일쓰레드 환경에서 유리
StringBuffer : Thread Safe 제공 (동기) -> 동기화란? : 순서에 맞게 일을 진행할때 1번의 일이 마쳐지고 나서야 다음 순번의 일을 진행하는 것(진행하고 있는 일이 마쳐지기 전까지 다음 일 진행하지 않음)
- 속도면에서는 StringBuilder 보다 성능 떨어짐
- 멀티쓰레드 환경에서 안전하게 동작할 수 있음

java언어의 특징은 멀티쓰레드 지원 : new Tread(); 사용하는 순간부터 지원

main 메서드가 쓰레드 한 개이므로 main메서드를 사용할 때는 단일 쓰레드 환경으로서 StringBuilder 사용 추천





------------------------------------ 단축키 ------------------------------------ 
ctrl + shift + O : import 안 된 모든 클래스 import
alt + shift + s : getter, setter 생성 단축키
alt + shift + j : 메서드 설명용 주석
------------------------------------ 기타 ------------------------------------ 
printf 를 String 반환형 메서드에서 return 구문 뒤에서 똑같이 사용하려면 String.format() 메서드 사용하면 됨

------------------------------------ 질문 ------------------------------------ 
예비군 3/7 말씀드리기 
공부방법
putIfAbsent() 질문